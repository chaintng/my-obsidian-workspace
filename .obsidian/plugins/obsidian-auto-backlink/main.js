/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AutoBacklinksPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  includedFolders: [],
  excludedFolders: [],
  useFrontmatter: true
};
var AutoBacklinksPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "generate-all-backlinks",
      name: "Generate Backlinks for All Markdown Files",
      callback: () => this.processAllFiles()
    });
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        if (file instanceof import_obsidian.TFile)
          this.handleFileChange(file);
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", (file, oldPath) => {
        if (file instanceof import_obsidian.TFile)
          this.handleFileChange(file);
      })
    );
    this.registerEvent(
      this.app.vault.on("delete", (file) => {
        if (file instanceof import_obsidian.TFile)
          this.handleFileDeletion(file);
      })
    );
    this.addSettingTab(new AutoBacklinksSettingTab(this.app, this));
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  shouldCreateBacklink(file) {
    var isExcluded = this.settings.excludedFolders.some(
      (folder) => file.path.startsWith(folder)
    );
    var isIncluded = this.settings.includedFolders.length == 0 || this.settings.includedFolders.some(
      (folder) => file.path.startsWith(folder)
    );
    return isIncluded && !isExcluded;
  }
  async processAllFiles() {
    new ConfirmationModal(this.app, async () => {
      const files = this.app.vault.getFiles().filter((file) => file.extension === "md" && this.shouldCreateBacklink(file));
      const notice = new import_obsidian.Notice("Processing files...", 0);
      const results = await Promise.all(
        files.map(
          (file) => this.generateBacklinksForFile(file).then(() => ({ success: true })).catch((error) => ({ error }))
        )
      );
      const processed = results.filter((result) => "success" in result).length;
      const errors = results.filter((result) => "error" in result).length;
      notice.setMessage(`Processed ${processed} files. Errors: ${errors}`);
    }).open();
  }
  async handleFileChange(file) {
    if (file.extension === "md" && this.shouldCreateBacklink(file)) {
      await this.generateBacklinksForFile(file);
      await this.updateBacklinksInParentFolders(file);
    }
  }
  async handleFileDeletion(file) {
    if (file.extension === "md" && this.shouldCreateBacklink(file)) {
      await this.removeBacklinksFromParentFolders(file);
    }
  }
  async generateBacklinksForFile(file) {
    if (file.extension !== "md" || !this.shouldCreateBacklink(file)) {
      return;
    }
    try {
      const content = await this.app.vault.read(file);
      const backlinks = this.generateBacklinks(file);
      const updatedContent = this.settings.useFrontmatter ? this.updateFrontmatter(content, backlinks) : this.updateBacklinksInContent(content, backlinks);
      if (content !== updatedContent) {
        await this.app.vault.modify(file, updatedContent);
      }
    } catch (error) {
      console.error(`Error generating backlinks for ${file.path}:`, error);
    }
  }
  generateBacklinks(file) {
    var _a, _b, _c;
    const backlinks = [];
    let currentFolder = file.parent;
    if (currentFolder) {
      const isFolderNoteFile = file.basename == ((_a = file.parent) == null ? void 0 : _a.name);
      if (isFolderNoteFile) {
        const parentFolder = (_b = currentFolder.parent) == null ? void 0 : _b.name;
        if (parentFolder) {
          backlinks.push(`[[${(_c = currentFolder.parent) == null ? void 0 : _c.name}]]`);
        }
      } else {
        backlinks.push(`[[${currentFolder.name}]]`);
      }
    }
    return backlinks.reverse();
  }
  updateBacklinksInContent(content, backlinks) {
    const backlinksRegex = /\n%% Auto-generated backlinks %%[\s\S]*?%% collapse-end %%|\n## Auto-generated Backlinks[\s\S]*?(?=\n#|$)|\n>\s\[\!AUTO-BACKLINKS\].*(?:\n> .*)*/g;
    content = content.replace(backlinksRegex, "").trim();
    const backlinksSection = backlinks.length !== 0 ? `

> [!AUTO-BACKLINKS] AUTO-BACKLINKS
> - ${backlinks.join("\n")}
` : "";
    return `${content}${backlinksSection}`;
  }
  updateFrontmatter(fileContent, backlinks) {
    const contentAfterRemoveBacklinkSection = this.updateBacklinksInContent(fileContent, []);
    const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
    const match = frontmatterRegex.exec(contentAfterRemoveBacklinkSection);
    const backlinksWithQuote = backlinks.map((backlink) => `"${backlink}"`);
    const url = backlinksWithQuote.join(", ");
    if (backlinksWithQuote.length == 0) {
      return contentAfterRemoveBacklinkSection;
    } else if (match) {
      const frontmatter = match[1];
      const updatedFrontmatter = frontmatter.includes("auto-backlink") ? frontmatter.replace(/auto-backlink: .*/, `auto-backlink: ${url}`) : `${frontmatter}
auto-backlink: ${url}`;
      return contentAfterRemoveBacklinkSection.replace(frontmatterRegex, `---
${updatedFrontmatter}
---`);
    } else {
      return `---
auto-backlink: ${url}
---
${contentAfterRemoveBacklinkSection}`;
    }
  }
  async updateBacklinksInParentFolders(file) {
    await this.iterateParentFolders(file, async (folder) => {
      const folderNoteFile = this.getFolderNoteFile(folder);
      if (folderNoteFile && folderNoteFile.extension === "md" && this.shouldCreateBacklink(folderNoteFile)) {
        await this.generateBacklinksForFile(folderNoteFile);
      }
    });
  }
  async removeBacklinksFromParentFolders(file) {
    await this.iterateParentFolders(file, async (folder) => {
      const folderNoteFile = this.getFolderNoteFile(folder);
      if (folderNoteFile && folderNoteFile.extension === "md" && this.shouldCreateBacklink(folderNoteFile)) {
        const content = await this.app.vault.read(folderNoteFile);
        const updatedContent = content.replace(`[[${file.path}]]`, "");
        if (content !== updatedContent) {
          await this.app.vault.modify(folderNoteFile, updatedContent);
        }
      }
    });
  }
  getFolderNoteFile(folder) {
    const folderNoteName = folder.name + ".md";
    const file = this.app.vault.getAbstractFileByPath(
      folder.path + "/" + folderNoteName
    );
    return file instanceof import_obsidian.TFile ? file : null;
  }
  async iterateParentFolders(file, callback) {
    let currentFolder = file.parent;
    while (currentFolder && currentFolder.path !== "/") {
      await callback(currentFolder);
      currentFolder = currentFolder.parent;
    }
  }
};
var AutoBacklinksSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Excluded folders").setDesc("Folders to exclude from backlink generation (one per line)").addTextArea(
      (text) => text.setPlaceholder("folder1\nfolder2/subfolder").setValue(this.plugin.settings.excludedFolders.join("\n")).onChange(async (value) => {
        this.plugin.settings.excludedFolders = value.split("\n").filter((folder) => folder.trim() !== "");
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Included folders").setDesc("Folders to included from backlink generation (one per line)").addTextArea(
      (text) => text.setPlaceholder("folder1\nfolder2/subfolder").setValue(this.plugin.settings.includedFolders.join("\n")).onChange(async (value) => {
        this.plugin.settings.includedFolders = value.split("\n").filter((folder) => folder.trim() !== "");
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Set Backlink on note property").setDesc("Set to true, to set backlink url in note's frontmatter property instead of bottom of the note").addToggle((toggle) => toggle.setValue(this.plugin.settings.useFrontmatter).onChange(async (value) => {
      this.plugin.settings.useFrontmatter = value;
      await this.plugin.saveSettings();
    }));
  }
};
var ConfirmationModal = class extends import_obsidian.Modal {
  constructor(app, onConfirm) {
    super(app);
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.setText(
      "Are you sure you want to generate backlinks for all Markdown files? This may take a while for large vaults."
    );
    const confirmButton = contentEl.createEl("button", { text: "Confirm" });
    const cancelButton = contentEl.createEl("button", { text: "Cancel" });
    confirmButton.addEventListener("click", () => {
      this.close();
      this.onConfirm();
    });
    cancelButton.addEventListener("click", () => this.close());
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
